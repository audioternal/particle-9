# The Power of 10 Rules in JavaScript

This document adapts NASA's "Power of 10 Rules" (originally written for C) to JavaScript. While JavaScript's dynamic nature differs from C, the core safety principles can be thoughtfully applied to create more reliable and secure web applications.

## Why Adapt These Rules to JavaScript?

JavaScript powers critical applications across the web, from banking to healthcare. Applying safety-critical principles helps prevent bugs, security vulnerabilities, and unexpected runtime behavior. Several developers have already explored this territory, including Karl Kenneth Alibuas, Thomas Sorreda, and the creator of the **NASA Biome** configuration .

## The Power of 10 Rules Adapted for JavaScript

The following table shows how each rule translates to JavaScript, with examples and enforcement strategies.

| Rule | JavaScript Adaptation | Example / Enforcement |
| :--- | :--- | :--- |
| **1. Simple Control Flow** | Avoid recursion; use iteration instead. Be cautious with labeled `break`/`continue`. Avoid `switch` statements (prone to missing `break` bugs) . | **Avoid recursion**:<br>```javascript<br>// ❌ Recursive (stack risk)<br>function factorial(n) {<br>  if (n <= 1) return 1;<br>  return n * factorial(n - 1);<br>}<br><br>// ✅ Iterative (safe)<br>function factorialSafe(n) {<br>  let result = 1;<br>  for (let i = 2; i <= n; i++) result *= i;<br>  return result;<br>}<br>```<br>*Enforce with ESLint: `no-restricted-syntax` for labeled statements* |
| **2. Fixed Loop Bounds** | Enforce explicit upper bounds on all loops. Use pagination to limit data processing. Prevent infinite loops . | **Bounded while loop**:<br>```javascript<br>const MAX_ITERATIONS = 1000;<br>let iterations = 0;<br>while (condition && iterations++ < MAX_ITERATIONS) {<br>  // Process safely<br>  if (iterations >= MAX_ITERATIONS) {<br>    console.warn('Loop exceeded safety limit');<br>    break;<br>  }<br>}<br>```<br>*Enforce with custom ESLint rules or runtime checks* |
| **3. Memory Management** | Original rule (no dynamic allocation) doesn't directly apply. Instead: control object growth, use fixed-size structures, implement pagination for data processing . | **Fixed-size cache**:<br>```javascript<br>class SafeCache {<br>  constructor(max = 100) {<br>    this.max = max;<br>    this.cache = new Map();<br>  }<br>  <br>  add(key, value) {<br>    if (this.cache.size >= this.max) {<br>      // Remove oldest entry<br>      const oldest = this.cache.keys().next().value;<br>      this.cache.delete(oldest);<br>    }<br>    this.cache.set(key, value);<br>  }<br>}<br>```<br>*Monitor with Chrome DevTools Memory tab* |
| **4. Function Size Limit** | Keep functions under 60 lines. Functions should do one thing well. Use composition over large functions . | ```javascript<br>// ❌ Too long (monolithic)<br>function processUserData(user) { /* 150 lines */ }<br><br>// ✅ Refactored (small, focused)<br>function validateUser(user) { /* 15 lines */ }<br>function formatUserData(user) { /* 12 lines */ }<br>function saveUser(user) { /* 8 lines */ }<br>```<br>*Enforce with ESLint: `max-lines-per-function: [ "error", 60 ]`* |
| **5. Runtime Assertions** | Use assertions liberally (minimum two per function). Fail fast and report exceptions. Validate inputs and states . | **Custom assertion utility**:<br>```javascript<br>function assert(condition, message) {<br>  if (!condition) {<br>    throw new Error(`Assertion failed: ${message}`);<br>  }<br>}<br><br>function divide(a, b) {<br>  assert(typeof a === 'number', 'a must be number');<br>  assert(typeof b === 'number', 'b must be number');<br>  assert(b !== 0, 'division by zero');<br>  return a / b;<br>}<br>```<br>*Use `console.assert()` in development, throw errors in production* |
| **6. Data Scope** | Avoid global variables. Declare variables at smallest possible scope. Use modules to encapsulate . | **Proper scoping**:<br>```javascript<br>// ❌ Global scope<br>userId = 123; // accidental global<br><br>// ✅ Block scope<br>function process() {<br>  const userId = 123; // block-scoped<br>  if (true) {<br>    const temp = 'only in this block';<br>  }<br>}<br><br>// ✅ Module scope<br>export class UserService {<br>  #privateField = 'encapsulated'; // private field<br>}<br>```<br>*Enforce with ESLint: `no-global-assign`, `no-implicit-globals`* |
| **7. Check Return Values** | Check function returns, especially from API calls, file operations, or any operation that can fail . | **Always check async operations**:<br>```javascript<br>// ❌ Ignoring return<br>fetch('/api/data'); // unhandled promise<br><br>// ✅ Proper checking<br>try {<br>  const response = await fetch('/api/data');<br>  if (!response.ok) {<br>    throw new Error(`HTTP error: ${response.status}`);<br>  }<br>  const data = await response.json();<br>  assert(data, 'Response data is empty');<br>} catch (error) {<br>  console.error('API call failed:', error);<br>  // Handle gracefully<br>}<br>```<br>*Enforce with ESLint: `no-unused-expressions`, `require-await`* |
| **8. Avoid Dangerous Features** | (Adapted from "Limited Preprocessor") Minimize meta-programming. Avoid `eval`, `new Function`, `with`, and `document.write` . | **Safe alternatives**:<br>```javascript<br>// ❌ Dangerous<br>eval('console.log("hello")');<br>const func = new Function('a', 'b', 'return a + b');<br>document.write('<script>malicious</script>');<br><br>// ✅ Safe alternatives<br>// Use JSON.parse for data<br>const data = JSON.parse(jsonString);<br>// Use template literals<br>element.textContent = `Hello, ${name}`;<br>// Use proper DOM methods<br>element.appendChild(newDiv);<br>```<br>*Enforce with ESLint: `no-eval`, `no-implied-eval`, `no-with`* |
| **9. Prevent XSS and Prototype Pollution** | (Adapted from "Limit Pointer Use") Sanitize user input. Use safe DOM methods. Prevent prototype pollution . | **XSS prevention**:<br>```javascript<br>// ❌ Dangerous (XSS vulnerable)<br>element.innerHTML = userInput;<br><br>// ✅ Safe<br>element.textContent = userInput;<br><br>// For HTML that must be rendered<br>import DOMPurify from 'dompurify';<br>element.innerHTML = DOMPurify.sanitize(userInput);<br><br>// ✅ Prevent prototype pollution<br>const safeMap = Object.create(null); // No prototype<br>// Or use Map<br>const map = new Map();<br>```<br>*Use DOMPurify, helmet.js for CSP headers* |
| **10. Use Strict Mode and Type Safety** | (Additional rule for JavaScript) Always use strict mode. Consider TypeScript for compile-time type checking . | **Enable strict mode**:<br>```javascript<br>'use strict';<br>// Prevents accidental globals<br>// Makes `this` behavior safer<br>// Disables dangerous features<br><br>// With TypeScript (recommended)<br>interface User {<br>  id: number;<br>  name: string;<br>}<br><br>function processUser(user: User): void {<br>  // Type-safe operations<br>  console.log(user.name.toUpperCase());<br>}<br>```<br>*Enforce with ESLint: `strict` rule, or use TypeScript* |

## JavaScript-Specific Safety Rules (Beyond NASA)

The original NASA rules don't cover web-specific concerns. Here are additional rules for JavaScript/TypeScript:

### 1. Content Security Policy
```javascript
// Set CSP headers to prevent XSS
// meta tag (limited) or server headers
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; script-src 'self'">